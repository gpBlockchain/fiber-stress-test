import time

import requests

import json

import logging
import random

LOGGER = logging.getLogger(__name__)

CKB_UNIT = 100000000

CKB_CELL_RETAIN = 62 * 100000000

class FiberRPCClient:
    def __init__(self, url, other_params={}, try_count=200):
        self.url = url
        self.other_params = other_params
        self.try_count = try_count

    def send_btc(self, btc_pay_req):
        return self.call("send_btc", [btc_pay_req])

    def build_router(self, param):
        return self.call("build_router", [param])

    def send_payment_with_router(self, param):
        return self.call("send_payment_with_router", [param])

    def abandon_channel(self, param):
        return self.call("abandon_channel", [param])

    def open_channel(self, param):
        """
        curl --location 'http://127.0.0.1:8227' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "open_channel",
            "params": [
                {
                    "peer_id": "QmaQSn11jsAXWLhjHtZ9EVbauD88sCmYzty3GmYcoVWP2j",
                    "funding_amount": "0x2e90edd000"
                }
            ]
        }'
        {"jsonrpc": "2.0", "result": {"temporary_channel_id": "0xbf1b507e730b08024180ed9cb5bb3655606d3a89e94476033cf34d206d352751"}, "id": 42}
        """
        return self.call("open_channel", [param])

    def list_channels(self, param):
        """
        curl --location 'http://127.0.0.1:8227' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "list_channels",
            "params": [
                {
                    "peer_id": "QmaQSn11jsAXWLhjHtZ9EVbauD88sCmYzty3GmYcoVWP2j"
                }
            ]
        }'
        {"jsonrpc": "2.0", "result": {"channels": [{"channel_id": "0x2329a1ced09d0c9eff46068ac939596bb657a984b1d6385db563f2de837b8879", "peer_id": "QmaQSn11jsAXWLhjHtZ9EVbauD88sCmYzty3GmYcoVWP2j", "state": {"state_name": "NEGOTIATING_FUNDING", "state_flags": "OUR_INIT_SENT | THEIR_INIT_SENT"}, "local_balance": "0x2d1f615200", "sent_tlc_balance": "0x0", "remote_balance": "0x0", "received_tlc_balance": "0x0", "created_at": "0x620a0b7b1676b"}]}, "id": 42}
        """
        return self.call("list_channels", [param])

    def update_channel(self, param):
        return self.call("update_channel", [param])

    def accept_channel(self, param):
        return self.call("accept_channel", [param])

    def add_tlc(self, param):
        return self.call("add_tlc", [param])

    def remove_tlc(self, param):
        return self.call("remove_tlc", [param])

    def shutdown_channel(self, param):
        return self.call("shutdown_channel", [param])

    def new_invoice(self, param):
        """
        payment_preimage = self.generate_random_preimage()
        invoice_balance = 100 * 100000000
        invoice = self.fiber2.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibb",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )
        Args:
            param:

        Returns:

        """
        return self.call("new_invoice", [param])

    def parse_invoice(self, param):
        """
        curl --location 'http://127.0.0.1:8228' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "parse_invoice",
            "params": [
                {
                    "invoice": "fibd1001pzthqlap8uhczxuy2fhdd08e9mqeqeuadfqrxf73sk63zdvl9jme4q7gespprunt6y5vnrvcyclptyl65cnth9l5zs9y34n0jcury5utass0a6tf6eklcz95gjg4lkert42jjmz2d44h5f9n3xnx85er3dh8zh6zlymwp604fxylj2jyg3fqsdfhwmeljhvc02cs9cnpn9tgl8sudpd927qnfctv8w6mu764lxzuwem9qfz2knzwdjcqgp6a6jwmfl5q08pjx0k9p9dljul4ceaq2nu60wwprm88lwdk98pdczc4tcxcwfa59jvancfdz8mselkuajtyeae86n7m4mtu6p5un693n7v48mpqut6lz6tppeut48nk54dhpv6a73gtlvf37tvyk4cqjnr9vv492jmkvu4meu2usp22a0av0lg358jpksps5le460tgqlkfzkn"
                }
            ]
        }'
        {"jsonrpc": "2.0", "result": {"invoice": {"currency": "Fibd", "amount": "0x64", "signature": "01141c131a0511131e0c15071b01001c0b1a1f021a0b0101191c0b1507131614150d17010c1a1d1e11080b1f0c09111e0b0c0416151800121303050c0c15050a121b160c1c151b191c0a1c10010a0a1d0f1d0c0f1f08111407120116100110141f19151a0f0b0800", "data": {"timestamp": "0x193423af465", "payment_hash": "0x2dedfa635c2b0c9aa70a3c5833f5f6e47337fedcd681a1b2cdea72c0ec576ac9", "attrs": [{"Description": "test invoice generated by node2"}, {"ExpiryTime": {"secs": 3600, "nanos": 0}}, {"UdtScript": "0x36000000100000003000000031000000229a4fc60fa8c4d65797f15178782e201486c3432cdf726c8be08197e28a1ea1040100000012"}, {"HashAlgorithm": "sha256"}, {"PayeePublicKey": "024ba813e2e683f421305811f71b2f607ef2780faa20283c30367fb255b9e7edde"}]}}}, "id": 42}

        """
        return self.call("parse_invoice", [param])

    def connect_peer(self, param):
        return self.call("connect_peer", [param])

    def cancel_invoice(self, param):
        return self.call("cancel_invoice", [param])

    def get_invoice(self, param):
        """
        curl --location 'http://127.0.0.1:8228' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "get_invoice",
            "params": [
                {
                    "payment_hash": "0x08f64fbcb38189aedb109ff049b6c8a20ba9b61a836fef35a6699c2004fe6902"
                }
            ]
        }'
        response:
        {"jsonrpc": "2.0", "result": {"invoice_address": "fibd11peseucdphcxgfw0pnm6vktap96klrlajceukj0q8wrshgjsryppgqzusjgf4ex560xfzxrj0et3hnws4zlgf3lly8csvwz2t4a6h7wap50qxf2mx4xw585ze4497k48f9y4g7rzg6h2gla7evwzu296y20t8jlwl0rjutcteyhyp6ymt4lfzyjf8k22l0q8gqnwm87jrj5knq45dqlw6yxqe0tlqg8638uhq9l0nh3ejrjc03mxam88u3v6wx46dqvy7chc2p0qn3lunckjmchxk9jc48qf34jzelpksqcgtt9c0pa87xnu2kza7x6r2dyg3flp9pkg6wsnyx54lrlqh0mnlafcqs2scnz7gqh8xyxs", "invoice": {"currency": "Fibd", "amount": "0x1", "signature": "0c041e1817180a010f0013111f1c131816121b181706160512181507000911151202191f0116100018080b0b05180f011d071e06131c0a16021d1e061a030a0d040811091f01050116081a0e1013040614151f031f00170f1b131f1d091800100a101813021e0800", "data": {"timestamp": "0x193287ae635", "payment_hash": "0x08f64fbcb38189aedb109ff049b6c8a20ba9b61a836fef35a6699c2004fe6902", "attrs": [{"Description": "test invoice generated by node2"}, {"ExpiryTime": {"secs": 3600, "nanos": 0}}, {"HashAlgorithm": "sha256"}, {"PayeePublicKey": "0299cbc950e551a2dc509000d801d768e714bf9bcfb11dde976e314bb1bb5c1af9"}]}}, "status": "Cancelled"}, "id": 42}
        """
        return self.call("get_invoice", [param])

    def disconnect_peer(self, param):
        return self.call("disconnect_peer", [param])

    def send_payment(self, param):
        return self.call("send_payment", [param])

    def get_payment(self, param):
        """
        curl --location 'http://127.0.0.1:8228' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "get_payment",
            "params": [
                {
                    "payment_hash": "0x03f43a02479d6901b53f88a4fa8a550786b1dad78d1bdb165a8afc8d19e89ffb"
                }
            ]
        }'
        {"jsonrpc": "2.0", "result": {"payment_hash": "0x03f43a02479d6901b53f88a4fa8a550786b1dad78d1bdb165a8afc8d19e89ffb", "status": "Success", "created_at": "0x192d868eaae", "last_updated_at": "0x6259d59d61040", "failed_error": null}, "id": 42}

        Args:
            param:

        Returns:

        """
        return self.call("get_payment", [param])

    def node_info(self):
        """
        curl --location 'http://127.0.0.1:8229' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "node_info",
            "params": [
                {}
            ]
        }'
        response:
        {"jsonrpc": "2.0", "result": {"version": "0.1.0", "commit_hash": "07174b5", "public_key": "03640b2a484786fd385813b250f910c5e4196acd62617dcf80a8f8797926c7d441", "node_name": null, "peer_id": "QmWcfdGWUqejDBZ7KwUPPvat2Y6wttACDz6XypLE56JCmf", "addresses": ["/ip4/127.0.0.1/tcp/8230/p2p/QmWcfdGWUqejDBZ7KwUPPvat2Y6wttACDz6XypLE56JCmf"], "chain_hash": "0x7ba63bdb2f401e6a922a6a6200bbd898c3b179a3035d5534324232af7808296c", "open_channel_auto_accept_min_ckb_funding_amount": "0x3c5986200", "auto_accept_channel_ckb_funding_amount": "0x1718c7e00", "tlc_expiry_delta": "0x5265c00", "tlc_min_value": "0x0", "tlc_max_value": "0x0", "tlc_fee_proportional_millionths": "0x3e8", "channel_count": "0x0", "pending_channel_count": "0x0", "peers_count": "0x0", "network_sync_status": "Running", "udt_cfg_infos": [{"name": "XUDT", "script": {"code_hash": "0xbb4469004225b39e983929db71fe2253cba1d49a76223e9e1d212cdca1f79f28", "hash_type": "type", "args": "0x.*"}, "auto_accept_amount": "0x3b9aca00", "cell_deps": [{"dep_type": "code", "tx_hash": "0xbf9cddee9210615b33d4ab6d24a0828390f5ae6bc46a3619817fdc8d1f4c9b8a", "index": "0x9"}]}]}, "id": 42}

        Returns:

        """
        return self.call("node_info", [{}])

    def graph_nodes(self, param={}):
        return self.call("graph_nodes", [param])

    def graph_channels(self, param={}):
        """
        curl --location 'http://127.0.0.1:8228' --header 'Content-Type: application/json' --data '{
            "id": 42,
            "jsonrpc": "2.0",
            "method": "graph_channels",
            "params": [
                {}
            ]
        }'
        response:
        {"jsonrpc": "2.0", "result": {"channels": [{"channel_outpoint": "0xdda035e80a1c4d7e449fd1ce381093fd36143ff456ce14f775fe2bfc0f7d857e00000000", "funding_tx_block_number": "0x60", "funding_tx_index": "0x0", "node1": "0257adc267e8e6eb08bcaa2340166bf8caca612974e9e6b8b5ec7697eacdf32830", "node2": "03cfe066b48515e368defcdc76090ef4c13c97270f5505c6a9627090931024776b", "last_updated_timestamp": "0x19349dc0615", "created_timestamp": 1732110972658, "node1_to_node2_fee_rate": "0x4b8ed0283a6d3df", "node2_to_node1_fee_rate": "0x4b8ed0283a6d3df", "capacity": "0x619a44600", "chain_hash": "0x7ba63bdb2f401e6a922a6a6200bbd898c3b179a3035d5534324232af7808296c", "udt_type_script": null}], "last_cursor": "0x60dda035e80a1c4d7e449fd1ce381093fd36143ff456ce14f775fe2bfc0f7d857e00000000"}, "id": 42}
        Returns:

        """
        return self.call("graph_channels", [param])

    def remove_watch_channel(self, param):
        return self.call("remove_watch_channel", [param])

    def get_peer_id(self):
        return self.node_info()["addresses"][0].split("/")[-1]

    def list_peers(self):
        return self.call("list_peers", [])

    def call(self, method, params):
        headers = {"content-type": "application/json"}
        headers.update(self.other_params)
        data = {"id": 42, "jsonrpc": "2.0", "method": method, "params": params}
        LOGGER.debug(
            "curl --location '{url}' --header 'Content-Type: application/json' --data '{data}'".format(
                url=self.url, data=json.dumps(data, indent=4)
            )
        )
        for i in range(self.try_count):
            try:
                response = requests.post(
                    self.url, data=json.dumps(data), headers=headers
                ).json()
                LOGGER.debug(
                    "response:\n{response}".format(response=json.dumps(response))
                )
                if "error" in response.keys():
                    error_message = response["error"].get("message", "Unknown error")
                    raise Exception(f"Error: {error_message}")

                return response.get("result", None)
            except requests.exceptions.ConnectionError as e:
                LOGGER.debug(e)
                LOGGER.debug("request too quickly, wait 2s")
                time.sleep(2)
                continue
        raise Exception("request time out")



def open_channel(fiber1, fiber2, capacity,udt=None):
    """
    打开一个通道
    确认通道创建成功
    """
    fiber2_node_info = fiber2.node_info()
    fiber1.connect_peer({"address": fiber2_node_info["addresses"][0]})
    time.sleep(1)
    fiber2_peer_id = fiber2_node_info["addresses"][0].split("/")[-1]
    open_channel_config = {
        "peer_id": fiber2_peer_id,
        "funding_amount": hex(capacity*CKB_UNIT),
        "tlc_fee_proportional_millionths": hex(1000),
        "public": True,
        "funding_udt_type_script": udt,
    }
    try:
        fiber1.open_channel(open_channel_config)
        wait_for_channel_state(fiber1, fiber2_peer_id, "CHANNEL_READY")
    except Exception as e:
        print(f"open channel failed:{e}")
    try:
        send_payment(fiber1,fiber2,int(capacity*CKB_UNIT/2),udt=udt)
    except Exception as e:
        print(f"send payment failed:{e}")

def send_payment(fiber1, fiber2, amount, wait=True, udt=None, try_count=5):
    for i in range(try_count):
        try:
            payment = fiber1.send_payment(
                {
                    "target_pubkey": fiber2.node_info()["node_id"],
                    "amount": hex(amount),
                    "keysend": True,
                    "allow_self_payment": True,
                    "udt_type_script": udt,
                }
            )
            if wait:
                wait_payment_state(
                    fiber1, payment["payment_hash"], "Success", 600, 0.05
                )
            return payment["payment_hash"]
        except Exception as e:
            time.sleep(1)
            continue
    payment = fiber1.send_payment(
        {
            "target_pubkey": fiber2.node_info()["node_id"],
            "amount": hex(amount),
            "keysend": True,
            "allow_self_payment": True,
            "udt_type_script": udt,
        }
    )
    if wait:
        wait_payment_state(
            fiber1, payment["payment_hash"], "Success", 600, 0.1
        )
    return payment["payment_hash"]


def send_invoice_payment(
     fiber1, fiber2, amount, wait=True, udt=None, try_count=5
):
    invoice = fiber2.new_invoice(
        {
            "amount": hex(amount),
            "currency": "Fibd",
            "description": "test invoice generated by node2",
            "expiry": "0xe1000",
            "payment_preimage": generate_random_preimage(),
            "hash_algorithm": "sha256",
            "udt_type_script": udt,
            "allow_mpp": True,
        }
    )
    for i in range(try_count):
        # payment = fiber1.get_client().send_payment(
        #     {
        #         "invoice": invoice["invoice_address"],
        #         "allow_self_payment": True,
        #         "dry_run": True,
        #         "max_parts":"0x40",
        #     }
        # )
        try:
            payment = fiber1.send_payment(
                {
                    "invoice": invoice["invoice_address"],
                    "allow_self_payment": True,
                    "max_parts": "0x40",
                }
            )
            if wait:
                wait_payment_state(fiber1, payment["payment_hash"], "Success")
            return payment["payment_hash"]
        except Exception as e:
            time.sleep(1)
            continue
    payment = fiber1.send_payment(
        {
            "invoice": invoice["invoice_address"],
            "allow_self_payment": True,
            "max_parts": "0x40",
        }
    )
    if wait:
        wait_payment_state(fiber1, payment["payment_hash"], "Success")
    return payment["payment_hash"]

def wait_payment_state(
     client, payment_hash, status="Success", timeout=360, interval=0.1
):
    for i in range(timeout):
        result = client.get_payment({"payment_hash": payment_hash})
        if result["status"] == status:
            return
        time.sleep(interval)
    raise TimeoutError(
        f"payment:{payment_hash} status did not reach state: {result['status']}, expected:{status} , within timeout period."
    )



def wait_for_channel_state(
    client,
    peer_id,
    expected_state,
    timeout=120,
    include_closed=False,
    channel_id=None,
):
    """Wait for a channel to reach a specific state.
    1. NEGOTIATING_FUNDING
    2. CHANNEL_READY
    3. CLOSED

    """
    for _ in range(timeout):
        channels = client.list_channels(
            {"peer_id": peer_id, "include_closed": include_closed}
        )
        if len(channels["channels"]) == 0:
            time.sleep(1)
            continue
        idx = 0
        if channel_id is not None:
            for i in range(len(channels["channels"])):
                print("channel_id:", channel_id)
                if channels["channels"][i]["channel_id"] == channel_id:
                    idx = i

        if channels["channels"][idx]["state"]["state_name"] == expected_state:
            LOGGER.info(f"Channel reached expected state: {expected_state}")
            # todo wait broading
            time.sleep(1)
            return channels["channels"][idx]["channel_id"]
        LOGGER.info(
            f"Waiting for channel state: {expected_state}, current state: {channels['channels'][0]['state']}"
        )
        time.sleep(1)
    raise TimeoutError(
        f"Channel did not reach state {expected_state} within timeout period."
    )

def generate_random_preimage():
    hash_str = "0x"
    for _ in range(64):
        hash_str += hex(random.randint(0, 15))[2:]
    return hash_str